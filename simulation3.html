<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>סימולטור זוויות אינטראקטיבי</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Heebo:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Heebo', sans-serif;
            background-color: #f8f9fa;
            overflow: hidden; /* Prevent scrolling while dragging */
            touch-action: none;
        }

        .canvas-container {
            position: relative;
            box-shadow: 0 10px 40px -10px rgba(0, 0, 0, 0.15); /* Stronger shadow for pop */
            border-radius: 1.5rem; /* More rounded */
            background-color: white;
            overflow: hidden;
        }

        #logo {
            position: absolute;
            top: 24px;
            right: 24px;
            width: 80px; /* Adjust size as needed */
            height: auto;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through */
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center bg-gray-50">

    <!-- Header / Info Panel - Floating -->
    <div class="absolute top-6 left-6 z-20 bg-white/95 backdrop-blur-sm p-5 rounded-2xl shadow-lg border border-gray-100 min-w-[200px]">
        <h1 class="text-xl font-bold text-gray-800 mb-1">חוקרים זוויות</h1>
        <p class="text-sm text-gray-500 mb-3">גררו את הנקודה האדומה</p>
        <div class="flex flex-col gap-1">
            <span class="font-bold text-blue-600 text-3xl" id="angle-display">45°</span>
            <span class="inline-block px-3 py-1 bg-blue-50 text-blue-700 rounded-lg text-sm font-semibold w-fit" id="type-display">זווית חדה</span>
        </div>
    </div>

    <!-- Logo PlaceHolder -->
    <img src="logo.png" alt="Amit Logo" id="logo" onerror="this.style.display='none'">

    <!-- Main Canvas Area - Enlarged and Centered -->
    <div class="canvas-container w-[95vw] h-[85vh] relative" id="container">
        <canvas id="geometryCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('geometryCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('container');
        const angleDisplay = document.getElementById('angle-display');
        const typeDisplay = document.getElementById('type-display');

        // State
        let width, height;
        let centerX, centerY;
        let isDragging = false;
        
        // Configuration
        let rayLength = 250; // Will be dynamic
        const handleRadius = 14; // Slightly larger for better touch
        let arcRadius = 100;     // Larger arc
        
        // The angle in radians (starts at 45 degrees)
        let currentAngle = Math.PI / 4; 

        function resize() {
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width * window.devicePixelRatio;
            canvas.height = height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;

            // Center the vertex horizontally and vertically (slightly lower than middle)
            centerX = width / 2; 
            centerY = height * 0.6;

            // Adjust ray length based on screen size
            rayLength = Math.min(width, height) * 0.35;
            arcRadius = Math.min(width, height) * 0.15;
            // Min caps for very small screens
            if (rayLength < 150) rayLength = 150;
            if (arcRadius < 60) arcRadius = 60;

            draw();
        }

        function getAngleType(degrees) {
            // Normalize exactly 360 to 0 for display logic
            if (Math.abs(degrees) < 0.1 || Math.abs(degrees - 360) < 0.1) return "זווית אפס / שלמה";
            if (degrees < 90) return "זווית חדה";
            if (Math.abs(degrees - 90) < 0.1) return "זווית ישרה";
            if (degrees < 180) return "זווית קהה";
            if (Math.abs(degrees - 180) < 0.1) return "זווית שטוחה";
            return "זווית נישאה";
        }

        function drawGrid() {
            ctx.save();
            ctx.strokeStyle = '#f0f2f5'; // Very subtle gray
            ctx.lineWidth = 1;

            const gridSize = 50;
            
            // Draw grid centered on the vertex
            // Vertical lines
            for (let x = centerX; x < width; x += gridSize) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke(); }
            for (let x = centerX; x > 0; x -= gridSize) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke(); }
            
            // Horizontal lines
            for (let y = centerY; y < height; y += gridSize) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke(); }
            for (let y = centerY; y > 0; y -= gridSize) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke(); }

            ctx.restore();
        }

        function draw() {
            // Clear
            ctx.clearRect(0, 0, width, height);

            // Draw Background Grid
            drawGrid();

            // Calculations
            // Base Ray (Fixed Horizontal)
            const endX1 = centerX + rayLength;
            const endY1 = centerY;

            // Moving Ray
            const endX2 = centerX + Math.cos(-currentAngle) * rayLength;
            const endY2 = centerY + Math.sin(-currentAngle) * rayLength;

            // 1. Draw Angle Arc (The colored slice)
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, arcRadius, 0, -currentAngle, true); 
            ctx.closePath();
            ctx.fillStyle = 'rgba(59, 130, 246, 0.15)'; 
            ctx.fill();
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 2. Draw Rays
            ctx.lineCap = 'round';
            ctx.lineWidth = 5; // Thicker lines
            ctx.strokeStyle = '#1e293b'; // Slate-800

            // Fixed Ray
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(endX1, endY1);
            ctx.stroke();

            // Moving Ray
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(endX2, endY2);
            ctx.stroke();

            // 3. Draw Vertex Point
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#0f172a'; // Darker
            ctx.fill();
            
            // Vertex Label
            ctx.fillStyle = '#64748b';
            ctx.font = '14px Heebo';
            ctx.textAlign = 'center';
            ctx.fillText('קודקוד', centerX, centerY + 30);


            // 4. Draw Interactive Handle (The Red Point)
            const handleDist = rayLength; // Put handle at tip for better leverage
            const handleX = centerX + Math.cos(-currentAngle) * handleDist;
            const handleY = centerY + Math.sin(-currentAngle) * handleDist;

            // Pulse/Glow effect if dragging
            if (isDragging) {
                ctx.beginPath();
                ctx.arc(handleX, handleY, handleRadius + 10, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(239, 68, 68, 0.2)';
                ctx.fill();
            }

            // The Red Dot
            ctx.beginPath();
            ctx.arc(handleX, handleY, handleRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#ef4444'; // Red-500
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            canvas.style.cursor = isDragging ? 'grabbing' : 'default';

            // 5. Update DOM Text
            let degrees = (currentAngle * (180 / Math.PI)).toFixed(0);
            if (degrees < 0) degrees = 360 + parseInt(degrees); 
            if (degrees == 360) degrees = 0;
            
            angleDisplay.textContent = `${degrees}°`;
            typeDisplay.textContent = getAngleType(degrees);
            
            // 6. Draw Degree Text on Canvas
            ctx.save();
            ctx.translate(centerX, centerY);
            const bisectorAngle = -currentAngle / 2;
            const textRadius = arcRadius + 40;
            ctx.fillStyle = '#1e293b';
            ctx.font = 'bold 20px Heebo'; // Larger font
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${degrees}°`, Math.cos(bisectorAngle) * textRadius, Math.sin(bisectorAngle) * textRadius);
            ctx.restore();
        }

        // --- Interaction Logic ---

        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
            const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function isNearHandle(x, y) {
            const handleDist = rayLength;
            const hx = centerX + Math.cos(-currentAngle) * handleDist;
            const hy = centerY + Math.sin(-currentAngle) * handleDist;
            const dx = x - hx;
            const dy = y - hy;
            return (dx * dx + dy * dy) < (handleRadius * 3.5) ** 2; // Generous hit area
        }

        function updateAngle(x, y) {
            const dx = x - centerX;
            const dy = y - centerY;
            let rawAngle = Math.atan2(dy, dx); 
            currentAngle = -rawAngle;

            while (currentAngle < 0) currentAngle += Math.PI * 2;
            while (currentAngle >= Math.PI * 2) currentAngle -= Math.PI * 2;

            draw();
        }

        // Event Listeners
        const startDrag = (e) => {
            const pos = getMousePos(e);
            // Allow clicking anywhere slightly away from center to start dragging
            const distFromCenter = Math.sqrt((pos.x - centerX)**2 + (pos.y - centerY)**2);
            
            if (isNearHandle(pos.x, pos.y) || (distFromCenter > 40)) {
                isDragging = true;
                updateAngle(pos.x, pos.y);
            }
        };

        const moveDrag = (e) => {
            if (!isDragging) {
                const pos = getMousePos(e);
                if (isNearHandle(pos.x, pos.y)) canvas.style.cursor = 'grab';
                else canvas.style.cursor = 'default';
                return;
            }
            e.preventDefault();
            const pos = getMousePos(e);
            updateAngle(pos.x, pos.y);
        };

        const endDrag = () => { isDragging = false; };

        canvas.addEventListener('mousedown', startDrag);
        window.addEventListener('mousemove', moveDrag);
        window.addEventListener('mouseup', endDrag);

        canvas.addEventListener('touchstart', (e) => { startDrag(e); }, {passive: false});
        window.addEventListener('touchmove', (e) => { if(isDragging) moveDrag(e); }, {passive: false});
        window.addEventListener('touchend', endDrag);

        window.addEventListener('resize', resize);
        
        document.fonts.ready.then(() => { resize(); });
        
    </script>
</body>
</html>
