<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>סימולטור זוויות אינטראקטיבי</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Heebo:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Heebo', sans-serif;
            background-color: #f8f9fa;
            overflow: hidden; /* Prevent scrolling while dragging */
            touch-action: none;
        }

        .canvas-container {
            position: relative;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            border-radius: 1rem;
            background-color: white;
            overflow: hidden;
        }

        #logo {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 80px; /* Adjust size as needed */
            height: auto;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through */
        }
        
        /* Custom tooltip for the drag point */
        .instruction-tip {
            position: absolute;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            pointer-events: none;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center p-4">

    <!-- Header / Info Panel -->
    <div class="absolute top-4 left-4 z-20 bg-white/90 backdrop-blur p-4 rounded-xl shadow-sm border border-gray-100 max-w-xs">
        <h1 class="text-xl font-bold text-gray-800 mb-1">חוקרים זוויות</h1>
        <p class="text-sm text-gray-500 mb-2">גררו את הנקודה האדומה לשינוי הזווית</p>
        <div class="flex items-center gap-2">
            <span class="font-bold text-blue-600 text-2xl" id="angle-display">45°</span>
            <span class="px-2 py-1 bg-gray-100 rounded text-sm font-medium text-gray-700" id="type-display">זווית חדה</span>
        </div>
    </div>

    <!-- Logo PlaceHolder -->
    <img src="logo.png" alt="Amit Logo" id="logo" onerror="this.style.display='none'">

    <!-- Main Canvas Area -->
    <div class="canvas-container w-full h-full max-w-5xl max-h-[80vh] relative" id="container">
        <canvas id="geometryCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('geometryCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('container');
        const angleDisplay = document.getElementById('angle-display');
        const typeDisplay = document.getElementById('type-display');

        // State
        let width, height;
        let centerX, centerY;
        let isDragging = false;
        
        // Configuration
        const rayLength = 250;
        const handleRadius = 12; // Radius of the red drag point
        const arcRadius = 80;    // Radius of the angle arc
        
        // The angle in radians (starts at 45 degrees)
        let currentAngle = Math.PI / 4; 

        function resize() {
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width * window.devicePixelRatio;
            canvas.height = height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;

            // Set center mostly to bottom left, but with padding
            centerX = width * 0.2; 
            centerY = height * 0.7;

            draw();
        }

        function getAngleType(degrees) {
            // Normalize exactly 360 to 0 for display logic if needed, but usually 360 is full circle
            if (Math.abs(degrees) < 0.1 || Math.abs(degrees - 360) < 0.1) return "זווית אפס / שלמה";
            if (degrees < 90) return "זווית חדה";
            if (Math.abs(degrees - 90) < 0.1) return "זווית ישרה";
            if (degrees < 180) return "זווית קהה";
            if (Math.abs(degrees - 180) < 0.1) return "זווית שטוחה";
            return "זווית נישאה";
        }

        function drawGrid() {
            ctx.save();
            ctx.strokeStyle = '#e5e7eb'; // Tailwind gray-200
            ctx.lineWidth = 1;

            const gridSize = 40;
            
            // Vertical lines
            for (let x = centerX % gridSize; x < width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = centerY % gridSize; y < height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            ctx.restore();
        }

        function draw() {
            // Clear
            ctx.clearRect(0, 0, width, height);

            // Draw Background Grid
            drawGrid();

            // Calculations
            // Base Ray (Fixed Horizontal)
            const endX1 = centerX + rayLength;
            const endY1 = centerY;

            // Moving Ray (Based on angle)
            // Note: Canvas Y is inverted (down is positive), so we subtract sin for visual "up"
            // But standard math atan2 handles dragging correctly if we map inputs right.
            // Let's stick to standard trig: 0 is right. -PI/2 is up.
            const endX2 = centerX + Math.cos(-currentAngle) * rayLength;
            const endY2 = centerY + Math.sin(-currentAngle) * rayLength;

            // 1. Draw Angle Arc (The colored slice)
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            // Arc logic: standard canvas arc draws clockwise. 
            // We want from 0 (fixed ray) to -currentAngle (moving ray).
            ctx.arc(centerX, centerY, arcRadius, 0, -currentAngle, true); 
            ctx.closePath();
            ctx.fillStyle = 'rgba(59, 130, 246, 0.2)'; // Blue-500 transparent
            ctx.fill();
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 2. Draw Rays
            ctx.lineCap = 'round';
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#1f2937'; // Gray-800

            // Fixed Ray
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(endX1, endY1);
            ctx.stroke();

            // Moving Ray
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(endX2, endY2);
            ctx.stroke();

            // 3. Draw Vertex Point (The corner)
            ctx.beginPath();
            ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
            ctx.fillStyle = '#111827'; // Dark
            ctx.fill();
            
            // Vertex Label
            ctx.fillStyle = '#4b5563';
            ctx.font = '14px Heebo';
            ctx.fillText('קודקוד', centerX - 20, centerY + 25);


            // 4. Draw Interactive Handle (The Red Point)
            // We place the handle slightly closer than full ray length for better UX
            const handleDist = rayLength * 0.8;
            const handleX = centerX + Math.cos(-currentAngle) * handleDist;
            const handleY = centerY + Math.sin(-currentAngle) * handleDist;

            // Outer glow for handle
            if (isDragging) {
                ctx.beginPath();
                ctx.arc(handleX, handleY, handleRadius + 8, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(239, 68, 68, 0.2)';
                ctx.fill();
            }

            // The Red Dot
            ctx.beginPath();
            ctx.arc(handleX, handleY, handleRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#ef4444'; // Red-500
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Cursor hint
            canvas.style.cursor = isDragging ? 'grabbing' : 'default';

            // 5. Update DOM Text
            let degrees = (currentAngle * (180 / Math.PI)).toFixed(0);
            if (degrees < 0) degrees = 360 + parseInt(degrees); // Normalize 0-360
            if (degrees == 360) degrees = 0;
            
            angleDisplay.textContent = `${degrees}°`;
            typeDisplay.textContent = getAngleType(degrees);
            
            // 6. Draw Degree Text on Canvas (next to arc)
            ctx.save();
            ctx.translate(centerX, centerY);
            // Position text in the middle of the angle bisector
            const bisectorAngle = -currentAngle / 2;
            const textRadius = arcRadius + 30;
            ctx.fillStyle = '#374151';
            ctx.font = 'bold 16px Heebo';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${degrees}°`, Math.cos(bisectorAngle) * textRadius, Math.sin(bisectorAngle) * textRadius);
            ctx.restore();
        }

        // --- Interaction Logic ---

        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
            const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function isNearHandle(x, y) {
            const handleDist = rayLength * 0.8;
            // Current handle position
            const hx = centerX + Math.cos(-currentAngle) * handleDist;
            const hy = centerY + Math.sin(-currentAngle) * handleDist;
            
            // Check distance
            const dx = x - hx;
            const dy = y - hy;
            // Larger hit area for easier touch
            return (dx * dx + dy * dy) < (handleRadius * 2.5) ** 2;
        }

        function updateAngle(x, y) {
            // Calculate angle relative to center
            const dx = x - centerX;
            const dy = y - centerY; // Canvas Y increases downwards
            
            // Standard atan2 returns angle from X axis (Right) clockwise is positive in screen coords usually?
            // Wait, in screen coords: Right=(1,0), Down=(0,1).
            // atan2(y, x) -> Down is +PI/2.
            // We want standard math behavior: Counter-Clockwise is positive.
            // But visually, "Up" is negative Y.
            
            // Let's simplify: Get the raw angle from the center
            let rawAngle = Math.atan2(dy, dx); 
            
            // Invert because canvas Y is down, but we treat "up" as positive angle conceptually often
            // Or simply, we treat dragging "up" from the right axis as positive.
            // Since y is positive down, moving mouse UP gives negative dy.
            // atan2(-y, x) gives negative angle for up.
            
            // Let's just strictly follow the mouse position visually
            // If mouse is at (10, -10) [relative to center], that's Top-Right.
            // atan2(-10, 10) = -PI/4.
            // We visualize using -currentAngle.
            // So if mouse gives -PI/4, we want currentAngle to be PI/4.
            
            currentAngle = -rawAngle;

            // Normalization logic to keep it 0-360 nice behavior
            while (currentAngle < 0) currentAngle += Math.PI * 2;
            while (currentAngle >= Math.PI * 2) currentAngle -= Math.PI * 2;

            draw();
        }

        // Event Listeners
        
        const startDrag = (e) => {
            const pos = getMousePos(e);
            // Check if user clicked near the red handle OR the vertex (for convenience)
            // though prompt specifically said vertex, usually rotating from the arm is better math UX.
            // We will allow dragging if they click anywhere on the outer 50% of the circle area to be generous
            const distFromCenter = Math.sqrt((pos.x - centerX)**2 + (pos.y - centerY)**2);
            
            if (isNearHandle(pos.x, pos.y) || (distFromCenter > 20 && distFromCenter < rayLength + 20)) {
                isDragging = true;
                updateAngle(pos.x, pos.y);
            }
        };

        const moveDrag = (e) => {
            if (!isDragging) {
                // Just for hover cursor update
                const pos = getMousePos(e);
                if (isNearHandle(pos.x, pos.y)) {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.style.cursor = 'default';
                }
                return;
            }
            e.preventDefault();
            const pos = getMousePos(e);
            updateAngle(pos.x, pos.y);
        };

        const endDrag = () => {
            isDragging = false;
        };

        // Mouse
        canvas.addEventListener('mousedown', startDrag);
        window.addEventListener('mousemove', moveDrag);
        window.addEventListener('mouseup', endDrag);

        // Touch
        canvas.addEventListener('touchstart', (e) => { startDrag(e); }, {passive: false});
        window.addEventListener('touchmove', (e) => { if(isDragging) moveDrag(e); }, {passive: false});
        window.addEventListener('touchend', endDrag);

        // Init
        window.addEventListener('resize', resize);
        
        // Wait for fonts to load for better canvas text rendering
        document.fonts.ready.then(() => {
            resize();
        });
        
    </script>
</body>
</html>
